// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class BorrowEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("reserve", Value.fromBytes(Bytes.empty()));
    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("onBehalfOf", Value.fromBytes(Bytes.empty()));
    this.set("blockNumber", Value.fromI32(0));
    this.set("blockTime", Value.fromI32(0));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BorrowEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BorrowEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BorrowEvent", id.toString(), this);
    }
  }

  static load(id: string): BorrowEvent | null {
    return changetype<BorrowEvent | null>(store.get("BorrowEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get reserve(): Bytes {
    let value = this.get("reserve");
    return value!.toBytes();
  }

  set reserve(value: Bytes) {
    this.set("reserve", Value.fromBytes(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get onBehalfOf(): Bytes {
    let value = this.get("onBehalfOf");
    return value!.toBytes();
  }

  set onBehalfOf(value: Bytes) {
    this.set("onBehalfOf", Value.fromBytes(value));
  }

  get amount(): BigDecimal | null {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set amount(value: BigDecimal | null) {
    if (!value) {
      this.unset("amount");
    } else {
      this.set("amount", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get interestRateMode(): i32 {
    let value = this.get("interestRateMode");
    return value!.toI32();
  }

  set interestRateMode(value: i32) {
    this.set("interestRateMode", Value.fromI32(value));
  }

  get borrowRate(): BigInt | null {
    let value = this.get("borrowRate");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set borrowRate(value: BigInt | null) {
    if (!value) {
      this.unset("borrowRate");
    } else {
      this.set("borrowRate", Value.fromBigInt(<BigInt>value));
    }
  }

  get blockNumber(): i32 {
    let value = this.get("blockNumber");
    return value!.toI32();
  }

  set blockNumber(value: i32) {
    this.set("blockNumber", Value.fromI32(value));
  }

  get blockTime(): i32 {
    let value = this.get("blockTime");
    return value!.toI32();
  }

  set blockTime(value: i32) {
    this.set("blockTime", Value.fromI32(value));
  }
}

export class RepayEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("reserve", Value.fromBytes(Bytes.empty()));
    this.set("borrower", Value.fromBytes(Bytes.empty()));
    this.set("repayer", Value.fromBytes(Bytes.empty()));
    this.set("blockNumber", Value.fromI32(0));
    this.set("blockTime", Value.fromI32(0));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RepayEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RepayEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RepayEvent", id.toString(), this);
    }
  }

  static load(id: string): RepayEvent | null {
    return changetype<RepayEvent | null>(store.get("RepayEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get amount(): BigDecimal | null {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set amount(value: BigDecimal | null) {
    if (!value) {
      this.unset("amount");
    } else {
      this.set("amount", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get reserve(): Bytes {
    let value = this.get("reserve");
    return value!.toBytes();
  }

  set reserve(value: Bytes) {
    this.set("reserve", Value.fromBytes(value));
  }

  get borrower(): Bytes {
    let value = this.get("borrower");
    return value!.toBytes();
  }

  set borrower(value: Bytes) {
    this.set("borrower", Value.fromBytes(value));
  }

  get repayer(): Bytes {
    let value = this.get("repayer");
    return value!.toBytes();
  }

  set repayer(value: Bytes) {
    this.set("repayer", Value.fromBytes(value));
  }

  get blockNumber(): i32 {
    let value = this.get("blockNumber");
    return value!.toI32();
  }

  set blockNumber(value: i32) {
    this.set("blockNumber", Value.fromI32(value));
  }

  get blockTime(): i32 {
    let value = this.get("blockTime");
    return value!.toI32();
  }

  set blockTime(value: i32) {
    this.set("blockTime", Value.fromI32(value));
  }

  get useATokens(): boolean {
    let value = this.get("useATokens");
    return value!.toBoolean();
  }

  set useATokens(value: boolean) {
    this.set("useATokens", Value.fromBoolean(value));
  }
}

export class LiquidationEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("collateralAsset", Value.fromBytes(Bytes.empty()));
    this.set("debtAsset", Value.fromBytes(Bytes.empty()));
    this.set("account", Value.fromBytes(Bytes.empty()));
    this.set("debtToCover", Value.fromBigDecimal(BigDecimal.zero()));
    this.set(
      "liquidatedCollateralAmount",
      Value.fromBigDecimal(BigDecimal.zero())
    );
    this.set("liquidator", Value.fromBytes(Bytes.empty()));
    this.set("blockTime", Value.fromI32(0));
    this.set("blockNumber", Value.fromI32(0));
    this.set("reserve", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LiquidationEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type LiquidationEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("LiquidationEvent", id.toString(), this);
    }
  }

  static load(id: string): LiquidationEvent | null {
    return changetype<LiquidationEvent | null>(
      store.get("LiquidationEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get collateralAsset(): Bytes {
    let value = this.get("collateralAsset");
    return value!.toBytes();
  }

  set collateralAsset(value: Bytes) {
    this.set("collateralAsset", Value.fromBytes(value));
  }

  get debtAsset(): Bytes {
    let value = this.get("debtAsset");
    return value!.toBytes();
  }

  set debtAsset(value: Bytes) {
    this.set("debtAsset", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get debtToCover(): BigDecimal {
    let value = this.get("debtToCover");
    return value!.toBigDecimal();
  }

  set debtToCover(value: BigDecimal) {
    this.set("debtToCover", Value.fromBigDecimal(value));
  }

  get liquidatedCollateralAmount(): BigDecimal {
    let value = this.get("liquidatedCollateralAmount");
    return value!.toBigDecimal();
  }

  set liquidatedCollateralAmount(value: BigDecimal) {
    this.set("liquidatedCollateralAmount", Value.fromBigDecimal(value));
  }

  get liquidator(): Bytes {
    let value = this.get("liquidator");
    return value!.toBytes();
  }

  set liquidator(value: Bytes) {
    this.set("liquidator", Value.fromBytes(value));
  }

  get receiveAToken(): boolean {
    let value = this.get("receiveAToken");
    return value!.toBoolean();
  }

  set receiveAToken(value: boolean) {
    this.set("receiveAToken", Value.fromBoolean(value));
  }

  get blockTime(): i32 {
    let value = this.get("blockTime");
    return value!.toI32();
  }

  set blockTime(value: i32) {
    this.set("blockTime", Value.fromI32(value));
  }

  get blockNumber(): i32 {
    let value = this.get("blockNumber");
    return value!.toI32();
  }

  set blockNumber(value: i32) {
    this.set("blockNumber", Value.fromI32(value));
  }

  get reserve(): Bytes {
    let value = this.get("reserve");
    return value!.toBytes();
  }

  set reserve(value: Bytes) {
    this.set("reserve", Value.fromBytes(value));
  }
}

export class Account extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Account must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Account", id.toString(), this);
    }
  }

  static load(id: string): Account | null {
    return changetype<Account | null>(store.get("Account", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get hasBorrowed(): boolean {
    let value = this.get("hasBorrowed");
    return value!.toBoolean();
  }

  set hasBorrowed(value: boolean) {
    this.set("hasBorrowed", Value.fromBoolean(value));
  }
}

export class AccountAToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("reserve", Value.fromString(""));
    this.set("account", Value.fromString(""));
    this.set("accrualBlockNumber", Value.fromBigInt(BigInt.zero()));
    this.set("enteredReserve", Value.fromBoolean(false));
    this.set("aTokenBalance", Value.fromBigDecimal(BigDecimal.zero()));
    this.set(
      "totalUnderlyingSupplied",
      Value.fromBigDecimal(BigDecimal.zero())
    );
    this.set(
      "totalUnderlyingRedeemed",
      Value.fromBigDecimal(BigDecimal.zero())
    );
    this.set("accountBorrowIndex", Value.fromBigDecimal(BigDecimal.zero()));
    this.set(
      "totalUnderlyingBorrowed",
      Value.fromBigDecimal(BigDecimal.zero())
    );
    this.set("totalUnderlyingRepaid", Value.fromBigDecimal(BigDecimal.zero()));
    this.set("storedBorrowBalance", Value.fromBigDecimal(BigDecimal.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AccountAToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccountAToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccountAToken", id.toString(), this);
    }
  }

  static load(id: string): AccountAToken | null {
    return changetype<AccountAToken | null>(store.get("AccountAToken", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get reserve(): string {
    let value = this.get("reserve");
    return value!.toString();
  }

  set reserve(value: string) {
    this.set("reserve", Value.fromString(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get accrualBlockNumber(): BigInt {
    let value = this.get("accrualBlockNumber");
    return value!.toBigInt();
  }

  set accrualBlockNumber(value: BigInt) {
    this.set("accrualBlockNumber", Value.fromBigInt(value));
  }

  get enteredReserve(): boolean {
    let value = this.get("enteredReserve");
    return value!.toBoolean();
  }

  set enteredReserve(value: boolean) {
    this.set("enteredReserve", Value.fromBoolean(value));
  }

  get aTokenBalance(): BigDecimal {
    let value = this.get("aTokenBalance");
    return value!.toBigDecimal();
  }

  set aTokenBalance(value: BigDecimal) {
    this.set("aTokenBalance", Value.fromBigDecimal(value));
  }

  get totalUnderlyingSupplied(): BigDecimal {
    let value = this.get("totalUnderlyingSupplied");
    return value!.toBigDecimal();
  }

  set totalUnderlyingSupplied(value: BigDecimal) {
    this.set("totalUnderlyingSupplied", Value.fromBigDecimal(value));
  }

  get totalUnderlyingRedeemed(): BigDecimal {
    let value = this.get("totalUnderlyingRedeemed");
    return value!.toBigDecimal();
  }

  set totalUnderlyingRedeemed(value: BigDecimal) {
    this.set("totalUnderlyingRedeemed", Value.fromBigDecimal(value));
  }

  get accountBorrowIndex(): BigDecimal {
    let value = this.get("accountBorrowIndex");
    return value!.toBigDecimal();
  }

  set accountBorrowIndex(value: BigDecimal) {
    this.set("accountBorrowIndex", Value.fromBigDecimal(value));
  }

  get totalUnderlyingBorrowed(): BigDecimal {
    let value = this.get("totalUnderlyingBorrowed");
    return value!.toBigDecimal();
  }

  set totalUnderlyingBorrowed(value: BigDecimal) {
    this.set("totalUnderlyingBorrowed", Value.fromBigDecimal(value));
  }

  get totalUnderlyingRepaid(): BigDecimal {
    let value = this.get("totalUnderlyingRepaid");
    return value!.toBigDecimal();
  }

  set totalUnderlyingRepaid(value: BigDecimal) {
    this.set("totalUnderlyingRepaid", Value.fromBigDecimal(value));
  }

  get storedBorrowBalance(): BigDecimal {
    let value = this.get("storedBorrowBalance");
    return value!.toBigDecimal();
  }

  set storedBorrowBalance(value: BigDecimal) {
    this.set("storedBorrowBalance", Value.fromBigDecimal(value));
  }

  get transactions(): Array<string> {
    let value = this.get("transactions");
    return value!.toStringArray();
  }

  set transactions(value: Array<string>) {
    this.set("transactions", Value.fromStringArray(value));
  }
}

export class AccountATokenTransaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("account", Value.fromString(""));
    this.set("tx_hash", Value.fromBytes(Bytes.empty()));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("block", Value.fromBigInt(BigInt.zero()));
    this.set("logIndex", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AccountATokenTransaction entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AccountATokenTransaction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("AccountATokenTransaction", id.toString(), this);
    }
  }

  static load(id: string): AccountATokenTransaction | null {
    return changetype<AccountATokenTransaction | null>(
      store.get("AccountATokenTransaction", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get account(): string {
    let value = this.get("account");
    return value!.toString();
  }

  set account(value: string) {
    this.set("account", Value.fromString(value));
  }

  get tx_hash(): Bytes {
    let value = this.get("tx_hash");
    return value!.toBytes();
  }

  set tx_hash(value: Bytes) {
    this.set("tx_hash", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get logIndex(): BigInt {
    let value = this.get("logIndex");
    return value!.toBigInt();
  }

  set logIndex(value: BigInt) {
    this.set("logIndex", Value.fromBigInt(value));
  }
}

export class Reserve extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("aTokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("stableDebtTokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("variableDebtTokenAddress", Value.fromBytes(Bytes.empty()));
    this.set("interestRateStrategyAddress", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Reserve entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Reserve must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Reserve", id.toString(), this);
    }
  }

  static load(id: string): Reserve | null {
    return changetype<Reserve | null>(store.get("Reserve", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get aTokenAddress(): Bytes {
    let value = this.get("aTokenAddress");
    return value!.toBytes();
  }

  set aTokenAddress(value: Bytes) {
    this.set("aTokenAddress", Value.fromBytes(value));
  }

  get stableDebtTokenAddress(): Bytes {
    let value = this.get("stableDebtTokenAddress");
    return value!.toBytes();
  }

  set stableDebtTokenAddress(value: Bytes) {
    this.set("stableDebtTokenAddress", Value.fromBytes(value));
  }

  get variableDebtTokenAddress(): Bytes {
    let value = this.get("variableDebtTokenAddress");
    return value!.toBytes();
  }

  set variableDebtTokenAddress(value: Bytes) {
    this.set("variableDebtTokenAddress", Value.fromBytes(value));
  }

  get interestRateStrategyAddress(): Bytes {
    let value = this.get("interestRateStrategyAddress");
    return value!.toBytes();
  }

  set interestRateStrategyAddress(value: Bytes) {
    this.set("interestRateStrategyAddress", Value.fromBytes(value));
  }

  get accruedToTreasury(): BigInt | null {
    let value = this.get("accruedToTreasury");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set accruedToTreasury(value: BigInt | null) {
    if (!value) {
      this.unset("accruedToTreasury");
    } else {
      this.set("accruedToTreasury", Value.fromBigInt(<BigInt>value));
    }
  }

  get liquidityIndex(): BigInt | null {
    let value = this.get("liquidityIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set liquidityIndex(value: BigInt | null) {
    if (!value) {
      this.unset("liquidityIndex");
    } else {
      this.set("liquidityIndex", Value.fromBigInt(<BigInt>value));
    }
  }

  get currentLiquidityRate(): BigInt | null {
    let value = this.get("currentLiquidityRate");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set currentLiquidityRate(value: BigInt | null) {
    if (!value) {
      this.unset("currentLiquidityRate");
    } else {
      this.set("currentLiquidityRate", Value.fromBigInt(<BigInt>value));
    }
  }

  get variableBorrowIndex(): BigInt | null {
    let value = this.get("variableBorrowIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set variableBorrowIndex(value: BigInt | null) {
    if (!value) {
      this.unset("variableBorrowIndex");
    } else {
      this.set("variableBorrowIndex", Value.fromBigInt(<BigInt>value));
    }
  }

  get currentVariableBorrowRate(): BigInt | null {
    let value = this.get("currentVariableBorrowRate");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set currentVariableBorrowRate(value: BigInt | null) {
    if (!value) {
      this.unset("currentVariableBorrowRate");
    } else {
      this.set("currentVariableBorrowRate", Value.fromBigInt(<BigInt>value));
    }
  }

  get currentStableBorrowRate(): BigInt | null {
    let value = this.get("currentStableBorrowRate");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set currentStableBorrowRate(value: BigInt | null) {
    if (!value) {
      this.unset("currentStableBorrowRate");
    } else {
      this.set("currentStableBorrowRate", Value.fromBigInt(<BigInt>value));
    }
  }

  get lastUpdateTimestamp(): i32 {
    let value = this.get("lastUpdateTimestamp");
    return value!.toI32();
  }

  set lastUpdateTimestamp(value: i32) {
    this.set("lastUpdateTimestamp", Value.fromI32(value));
  }

  get unbacked(): BigInt | null {
    let value = this.get("unbacked");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set unbacked(value: BigInt | null) {
    if (!value) {
      this.unset("unbacked");
    } else {
      this.set("unbacked", Value.fromBigInt(<BigInt>value));
    }
  }

  get isolationModeTotalDebt(): BigInt | null {
    let value = this.get("isolationModeTotalDebt");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set isolationModeTotalDebt(value: BigInt | null) {
    if (!value) {
      this.unset("isolationModeTotalDebt");
    } else {
      this.set("isolationModeTotalDebt", Value.fromBigInt(<BigInt>value));
    }
  }
}
